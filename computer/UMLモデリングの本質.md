# 情報システムとモデリング
- 1980年代 最小まで機能分割したものの仕様を定義して実装するPOAが主流
- 1980年代後半 RDBが登場し、データから先に分析するDOAが主流に
- 1990年代 オブジェクト指向（OOA）に移行され始める

### それぞれのレイヤ化アーキテクチャの違い
- POA・DOA
  - ユーザーインターフェース層
  - アプリケーション層
  - データベース層
- OOA
  - ユーザーインターフェース層
  - アプリケーション層
  - アプリケーションファサード
  - ドメイン層
  - 永続層

### メリット・デメリット
- モデリング（適切な表現と変更への対応）
  - POA・DOA
    - 画面や帳票を表現する対応する大量のモデルから構成され、本質的に同じ属性があちこちにばら撒かれるため変更に弱い。
    - モデルがそのままRDB等のDB製品上に格納される（概念モデルであると同時に物理モデルになる）ため、物理的な制約やパフォーマンス優先によって概念モデルが歪められる。
  - OOA
    - 概念モデルと物理モデルは完全に分離され、概念モデル上に本質的な属性が管理されるため変更に強い。
- ビジネスロジックやルール
  - POA・DOA
    - ビジネスロジックやルールがアプリケーション層の複数のソースコードに散らばるため変更に弱い。
  - OOA
    - ドメイン層のロジックに集約される。

# 型図の作成技法

作成するダイアグラム一覧
- **業務領域を表現するために作る＝メインの成果物  
  （要は最終的にこれが出来上がれば良い）**
  - 型図… ドメインモデル
- **システムが動いた時の考慮を型図に反映したり検証するために作る＝サブ的な成果物  
  （これらを今後の開発のために成果物として管理・メンテしていくことは自然だが、一部はあえて残さない選択もあり）**
  - 業務フロー図… ToBe業務の表現・ユースケースの発見
  - ユースケース図… アクターとユースケースの整理
  - ユースケース記述… システムのインターフェースと処理内容の発見
  - ロバストネス図…. ユースケースの妥当性確認
  - シーケンス図… ドメインモデルの振る舞い発見・割り当て
  - インスタンス図… インスタンス間のリンクの不都合や冗長性を発見・排除
  - ステートマシン図… インスタンスの状態フローの妥当性確認

# メモ

- 概念モデル
  - 概念同士の関連図。それぞれの概念は属性と振る舞いを持つ。
- 仕様モデル（暗示的）
  - 概念モデルと実装モデルにはギャップがあるため、実装モデルへの落とし込み方（＝実装方針）の情報を含めた**概念モデル**。
    （ギャップとは動的分類や多重分類はJava等のオブジェクト指向言語でそのまま扱えない、概念とクラスが1対1になるとは限らない等）
- 仕様モデル（明示的）
  - 概念モデルと実装モデルにはギャップがあるため、実装モデルへの落とし込み方（＝実装方針）を示すために作成する**クラス図**。
    ギャップに対してどのようなクラス群になるか、属性や振る舞いの割当がどうなるかを示せていれば良い。
    つまりギャップのない部分まで作成する必要はない（全て作ってしまったらそれは実装モデルになる）。
    仕様モデルがあることにより、概念モデルから実装モデルへの実装方針が明確となり人によるバラツキが減るため、作業分担しつつ品質を確保できる。
- 実装モデル
  - クラス図。場合によっては仕様モデルと差異がない。

```uml
@startuml
Alice -> Bob: Authentication Request
Bob --> Alice: Authentication Response

Alice -> Bob: Another authentication Request
Alice <-- Bob: another authentication Response
@enduml
```
