# 情報システムとモデリング
- 1980年代 最小まで機能分割したものの仕様を定義して実装するPOAが主流
- 1980年代後半 RDBが登場し、データから先に分析するDOAが主流に
- 1990年代 オブジェクト指向（OOA）に移行され始める

### それぞれのレイヤ化アーキテクチャの違い
- POA・DOA
  - ユーザーインターフェース層
  - アプリケーション層
  - データベース層
- OOA
  - ユーザーインターフェース層
  - アプリケーション層
  - アプリケーションファサード
  - ドメイン層
  - 永続層

### メリット・デメリット
- モデリング（適切な表現と変更への対応）
  - POA・DOA
    - 画面や帳票を表現する対応する大量のモデルから構成され、本質的に同じ属性があちこちにばら撒かれるため変更に弱い。
    - モデルがそのままRDB等のDB製品上に格納される（概念モデルであると同時に物理モデルになる）ため、物理的な制約やパフォーマンス優先によって概念モデルが歪められる。
  - OOA
    - 概念モデルと物理モデルは完全に分離され、概念モデル上に本質的な属性が管理されるため変更に強い。
- ビジネスロジックやルール
  - POA・DOA
    - ビジネスロジックやルールがアプリケーション層の複数のソースコードに散らばるため変更に弱い。
  - OOA
    - ドメイン層のロジックに集約される。


# メモ

- 概念モデル
  - 概念同士の関連図。それぞれの概念は属性と振る舞いを持つ。
- 仕様モデル（暗示的）
  - 概念モデルと実装モデルにはギャップがあるため、実装モデルへの落とし込み方（＝実装方針）の情報を含めた**概念モデル**。
    （ギャップとは動的分類や多重分類はJava等のオブジェクト指向言語でそのまま扱えない、概念とクラスが1対1になるとは限らない等）
- 仕様モデル（明示的）
  - 概念モデルと実装モデルにはギャップがあるため、実装モデルへの落とし込み方（＝実装方針）を示すために作成する**クラス図**。
    ギャップに対してどのようなクラス群になるか、属性や振る舞いの割当がどうなるかを示せていれば良い。
    つまりギャップのない部分まで作成する必要はない（全て作ってしまったらそれは実装モデルになる）。
    仕様モデルがあることにより、概念モデルから実装モデルへの実装方針が明確となり人によるバラツキが減るため、作業分担しつつ品質を確保できる。
- 実装モデル
  - クラス図。場合によっては仕様モデルと差異がない。

```uml
@startuml
Alice -> Bob: Authentication Request
Bob --> Alice: Authentication Response

Alice -> Bob: Another authentication Request
Alice <-- Bob: another authentication Response
@enduml
```
