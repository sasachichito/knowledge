# 情報システムとモデリング
- 1980年代 最小まで機能分割したものの仕様を定義して実装するPOAが主流
- 1980年代後半 RDBが登場し、データから先に分析するDOAが主流に
- 1990年代 オブジェクト指向（OOA）に移行され始める

### それぞれのレイヤ化アーキテクチャの違い
- POA・DOA
  - ユーザーインターフェース層
  - アプリケーション層
  - データベース層
- OOA
  - ユーザーインターフェース層
  - アプリケーション層
  - アプリケーションファサード
  - ドメイン層
  - 永続層

### メリット・デメリット
- モデリング（適切な表現と変更への対応）
  - POA・DOA
    - 画面や帳票を表現する対応する大量のモデルから構成され、本質的に同じ属性があちこちにばら撒かれるため変更に弱い。
    - モデルがそのままRDB等のDB製品上に格納される（概念モデルであると同時に物理モデルになる）ため、物理的な制約やパフォーマンス優先によって概念モデルが歪められる。
  - OOA
    - 概念モデルと物理モデルは完全に分離され、概念モデル上に本質的な属性が管理されるため変更に強い。
- ビジネスロジックやルール
  - POA・DOA
    - ビジネスロジックやルールがアプリケーション層の複数のソースコードに散らばるため変更に弱い。
  - OOA
    - ドメイン層のロジックに集約される。

# 型図の作成技法

作成するダイアグラム一覧
- **業務領域を表現するために作る＝メインの成果物  
  （要は最終的にこれが出来上がれば良い）**
  - 型図… ドメインモデル
- **システムが動いた時の考慮を型図に反映したり検証するために作る＝サブ的な成果物  
  （これらを今後の開発のために成果物として管理・メンテしていくことは自然だが、一部はあえて残さない選択もあり）**
  - 業務フロー図… ToBe業務の表現・ユースケースの発見
  - ユースケース図… アクターとユースケースの整理
  - ユースケース記述… システムのインターフェースと処理内容の発見
  - ロバストネス図…. ユースケースの妥当性確認
  - シーケンス図… ドメインモデルの振る舞い発見・割り当て
  - インスタンス図… インスタンス間のリンクの不都合や冗長性を発見・排除
  - ステートマシン図… インスタンスの状態フローの妥当性確認

# メモ

- 概念モデル
  - 概念同士の関連図。それぞれの概念は属性と振る舞いを持つ。
- 狭義の仕様モデル
  - 明示的仕様モデル... 概念モデル（主にドメインモデルとユースケース）をもとに必要なクラスと、クラス間でやり取りされるメッセージ（クラスのインターフェース）を定義したもの。これにより主なクラスが発見され、そのクラスに責務が割り当たることになる。ただし内部クラスやプライベートメソッドなど、実際に必要になる全てのクラスが含まれる最終的なクラス図（実装モデルのこと）とは異なる。
  - 暗示的仕様モデル... クラスを考えずに、概念モデル間でやり取りされるメッセージ（概念のインターフェース）を定義したもの。明示的仕様モデルと比較して多くの情報を運べる。
- 広義の仕様モデル
  - 概念モデルをどのように実装モデルへ落とし込むか（＝実装方針）を定義したもの （概念モデルの動的分類や多重分類はJava等のオブジェクト指向言語でそのまま扱えないため、実装モデルへ落とすには方針・ルールが必要）。成果物としては狭義の仕様モデルに加えて、使用言語・インフラ環境（オンプレ、IaaS、CaaS等）、アーキテクチャスタイル、アーキテクチャパターン、ミドルウェア、データモデル、処理のインターフェース（I/O)等がある。
   - アーキテクチャスタイル... ソースコードの構造化方針、デプロイ単位方針、サービス間連携方針
   - アーキテクチャパターン... アーキテクチャスタイルの中で特定の問題（スケーラビリティやパフォーマンスの向上など）を解決するための構造。
- 実装モデル
  - 実装する内容を示す成果物。クラス図。

```uml
@startuml
Alice -> Bob: Authentication Request
Bob --> Alice: Authentication Response

Alice -> Bob: Another authentication Request
Alice <-- Bob: another authentication Response
@enduml
```
