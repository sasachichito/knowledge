# アナリシスパターン  
## 導入
ビジネスの問題領域があり、そこにある概念をもれなく捉え、それらを実装することでソフトウェアが完成するとしたら、  
GoFのデザインパターンは、実装の仕方のカタログであり、  
アナリシスパターンは、概念の捉え方のカタログである。  
  
概念を捉えた結果として出来上がる表現がモデルである。  
その際にオブジェクト指向を用いたのであればオブジェクトモデルと呼ぶ。  
  
モデル化の最大の問題は、モデル化領域に対する開発者の恣意性にある。  
```  
恣意性... 言語が指し示すものと、それを示す言語記号の間には必然的な結びつきはないこと。  
```  
恣意性の排除は、再利用可能なモデリングにおいて最大の関心事になる。    
  
## モデルの種類  
概念モデル... その世界について表現する。  
これは技術的問題を無視した心的描写である。  
実世界をそのまま表すか、その世界について知っていることを表すかのどちらかに分かれる。  
後者はつまりドメインにおけるモデルとなり、ソフトウェアを開発する上で有利である。  
（例えば実世界の「人」には誕生日があるが、ドメインにとって誕生日がなくても問題ないのなら誕生日がない「人」を扱う。この「人」は実世界を表していないが、逆に実世界を現したモデルは関心事が多すぎてソフトウェア開発に向かない。）  
  
暗示的仕様モデル... 「概念モデル」と「それがどのようにして具体的なインターフェース（メソッドなど）に解決されるかを示す規約」を組み合わせたもの。  
  
明示的仕様モデル... 具体的なインターフェースを表現するモデル。どんな操作が存在するか、その引数と戻り値を詳細に述べる。  
  
実装モデル... クラス図。具体的なインターフェースに加え、内部のデータ等、実装に必要な情報を含むモデル。  
  
アナリシスパターンが扱うモデルは、概念モデルか暗示的仕様モデルとなる。  
これらから明示的仕様モデル、実装モデルへの変換には「設計テンプレート」と呼ばれる規約・ルールが利用される。  
```
概念モデル（暗示的仕様モデル）
↓
↓ [設計テンプレート]
↓
実装モデル（明示的仕様モデル）
```
  
## 型図
アナリシスパターンでのモデルは型図である。  
型図は1つ以上の型から構成され、1つの型は矩形で表現される。  
概念モデル（暗示的仕様モデル）であるので型はクラスではない。  
  
## 関連と対応づけ  
関連は、型を元にしたインスタンス間の関係を表している。  
概念モデルにおける関連は、概念的に関係があることを示す。  
実装モデルにおける関連は、そのままポインタを表す。  
  
対応づけは、型から型への直接のリンクである。つまり型図の中で使われる表現である。  
多重度があり、その上限が1である対応づけを単値対応づけ、2以上のものを多値対応づけと呼ぶ。  
  
型図に対応づけの表記があるということは、それらの型を元にしたインスタンス間に「関連」があることを意味する。  
型Aと型Bに1つの対応づけがあるということは、（インスタンスの世界において）AからBへの方向か、その逆の方向どちらかの関連がある。  
型Aと型Bに2つの対応づけがあるということは、（インスタンスの世界において）AとBの双方向に関連がある。  
アナリシスパターンの型図では、対応づけが1つなのか2つなのかは必ずしも明記されない。  
  
導出対応づけとは、それがそのモデル上に現れる他の対応づけに基づいていることを表す。例えば  
「祖父」型が導出対応づけされている型図がある場合、この祖父を導出できる対応づけが型図のどこかにある。（例えば父ー親の対応づけ）  
この場合実装モデルで必ずしも「祖父」クラスを用意せずとも、父クラスの親属性から取得できる。  
  
## 汎化  
概念モデルでは汎化を「タイプ」（スーパータイプ、サブタイプ）という言葉で表現する。  
実装モデルでは「クラス」（スーパークラス、サブクラス）で表現するが、「タイプ」とは異なる。  
サブクラス化はサブタイプ化の実装方法の一つでしかない。  
なぜならサブクラス化はサブタイプ化がなくても利用できる。例えば実装クラスの継承など。  
インターフェースの継承はサブタイプ化の実装方法である。  
  
サブタイプ化は、単一型つけではなく、多重型つけの考え方を用いる。  
単一型つけは  
概念モデルで複数のスーパータイプを持ちうる単一のサブタイプ型を定義する。実装モデルでは多重継承で表現する。  
多重型つけは、  
概念モデルで特定の型を定義することなしに、実装モデルで目的に応じて1つのオブジェクトに対して複数のサブタイプ型となることを許す。  
多重型つけがないと型が増えすぎてしまうし、何より概念的に多重型つけの方が自然である。  
  
サブタイプ化は、静的型つけではなく、動的型つけの考え方を用いる。  
静的型つけは、  
オブジェクトは別のサブタイプに動的に変更できない。  
動的型つけは、  
[不変]と明示しない限り動的に変更できる。  
動的型つけの方が概念的に自然であるが複雑さが増すため、概念モデルで動的なサブタイプでも動的型つけをサポートする費用をかけれない場合には  
明示的仕様モデルにおいては静的と宣言したり、実装モデルでは動的な変更をサポートしないことが多い。  
  
## 知識レベル  
ドメインを表現する概念には存在意義（役割）がある。その概念は「知識レベル」と「操作（業務）レベル」どちらだろうか？  
概念モデルを描くとき、一つの四角形は一つの概念に対応する。  
その四角形は「知識レベル」と「操作レベル」のどちらかに属する。  
  
アナリシスパターンにおいては以下のように言及されている。  
```  
操作レベルのモデルがドメインの日々の出来事を記録するのに対して、知識レベルのモデルはこの構造を支配する一般的ルールを記録する。  
知識レベルという概念を導入することによってその複雑さを管理できる。  
```  
  
エリック・エヴァンスのドメイン駆動設計においては以下のように言及されている。（結局はMartin Fowlerの引用だが）  
```  
知識レベルとは他のオブジェクトがどう振る舞うべきか記述するオブジェクトグループである。  
知識レベルはモデルを構造化する。  
```  
※構造化とは、整理し体系化し、全体の見通しをよくすることだと考えている。  
  
アナリシスパターンの表現が非常にわかりやすいと思う。  
システムのユーザーの操作を記録するのが操作レベルのモデル、ユーザーの操作にルールを与えているのが知識レベルのモデルである。  
ドメイン駆動設計においては、区分オブジェクトや仕様オブジェクトが知識レベルのモデルの実装モデルになる。  
```  
仕様クラス...     
集約のルートにはドメインの振る舞いを扱う責務があるため、    
いくら集約の境界を参照できるとはいえバリデーションの責務を持たせると責務が増えすぎてしまう。    
そのため集約が仕様を満たしているかチェックする仕様クラスを用意し、集約のルートにvalidate()メソッドでそれを利用しチェックさせる。    
これを仕様パターンという。   
```  
仕様パターンとはつまり、操作レベルと知識レベルのモデルを分離することが目的だった。  
