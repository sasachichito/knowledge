※画像はWebもしくは「Clean Architecture　達人に学ぶソフトウェアの構造と設計 (アスキードワンゴ) Kindle版」から引用  

# SRP：単一責任原則  
アクターの異なるコードは分離するべきだ。  
※アクター... 変更を望む人たちをひとまとめにしたグループ。  
同じような変更を望む人たちは同じグループであり一つのアクターで表現される。  
  
3つのアクターを持つEmployeeクラスがある場合の対策：  
3つのアクターの要望に応える3つのメソッドを、3つのドメインサービスとして切り出す。  
さらに利便性のために3つのドメインサービスを取りまとめるFacadeを用意しても良いし、  
データの近くに振る舞いを持たせたければEmployeeにドメインサービスをダブルディスパッチさせる方法もある。  
  
そもそも3種類のEmployeeクラスにモデリングすることが正しいだろう。  


# OCP：オープン・クローズドの原則  
変更の影響を受けずにシステムを拡張しやすくするべきだ。  
方向の制御と情報隠蔽により実現する。  
### 方向の制御  
依存関係逆転の原則（DIP）を適用する。つまり処理の流れ（方針→詳細）と依存関係を逆転させるが、  
そのときビジネスロジック（ドメイン層）が最上位となるように設計する。（ドメイン層が詳細に依存しない）  
  
### 情報隠蔽  
ドメイン層の利用者がドメイン層の内部を知りすぎないように、ドメイン層側にインターフェースを用意する。  
これにより利用者がドメインオブジェクトに推移的に依存することを防ぎ、ドメイン層の変更の影響を受けないようにする。  
推移的な依存関係は「ソフトウェアのエンティティは自分が直接使っていないものに依存すべきではない」という大原則に違反しており、  
これはインターフェース分離の原則（ISP）や全再利用の原則（CRP）が関連する。  
  
  
# コンポーネントの凝集性に関する原則（REP・CCP・CRP）の関係性  
REP・CCP・CRPはそれぞれ目的が異なる。これらに従ったプラクティスは  
目的を達成するためにパッケージを大きくするものもあれば、小さくするものもある。  
相反する動きがあるためアーキテクトはバランスを取りながら「いいとこ取り」していく。  
<img src="/picture/クリーンアーキテクチャ13.png" width="600px">
  
### 再利用・リリース等価の原則：REP  
- 視点
  - 利用者視点

- どういう法則か
  - コンポーネント（ソースコードの集合）に対してリリースバージョンが振られる
  - コンポーネントを利用するときはリリースバージョンを指定する
  - リリースの内容はリリースドキュメントに記載され、適切に通知される
  - リリースの内容を見て、適用するか否か、いつ適用するか決める
  - コンポーネントが他のコンポーネントに依存する場合は、リリースの度に互換性を確認する

- この法則があるから何なのか
  - 一つのコンポーネントには一貫したテーマや目的を持つコードを含めるべき。  
    なぜなら関心のあるコードが複数コンポーネントにまたがっているとそれら全てのリリースの内容確認、互換性チェックが必要になり大変になるから。
  
##### REPに従うプラクティスはコンポーネントを大きくする。  
  
### 閉鎖性共通の原則：CCP  
- 視点
  - 開発者視点

- どういう法則か
  - 変更するコードが一つのコンポーネントにまとまっていれば、デプロイするのはそのコンポーネントだけで良い

- この法則があるから何なのか
  - 一つのコンポーネントには変更の理由が似ているコードをまとめておくべき  
    なぜならコードを変更した時にデプロイするコンポーネント数が少なくて済むから。

##### CCPに従うプラクティスはコンポーネントを大きくする。  
  
### 全再利用の原則：CRP  
- 視点
  - 利用者視点

- どういう法則か
  - コンポーネント同士に依存関係があるとき、使われる側のコンポーネントが変更されるたびに、使う側のコンポーネントにも変更が必要になる。仮に変更が不要でも、再コンパイルや再デプロイが必要になる可能性が高い。変更された箇所が、使う側のコンポーネントに関係ないところだったとしても、その可能性は変わらない。

- この法則があるから何なのか
  - 一つのコンポーネントにはどれも切り離せないクラスだけをまとめておくべき
  - 言い換えるとコンポーネントに依存するのであれば、コンポーネントに含まれる全てのクラスに依存するようにしておくべき。  
    なぜならコードを変更したときにそのコンポーネント内の全てのコードに手を加えることになるため、変更してないけどデプロイされるコードがなくなり、ひいてはこのコンポーネントの利用者にとって無関心な変更が発生しなくなることで、無駄な変更内容確認と適用作業がなくなるから。

  
##### CRPに従うプラクティスはコンポーネントを小さくする。  
  

# その他の原則
「アジャイルソフトウェア開発の奥義」を参照  
https://github.com/sasachichito/knowledge/blob/master/computer/%E3%82%A2%E3%82%B8%E3%83%A3%E3%82%A4%E3%83%AB%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%E9%96%8B%E7%99%BA.md  


# 独立性  
優れたアーキテクチャは以下のことをサポートしなければならない。  
```
・システムのユースケース
・システムの運用
・システムの開発
・システムのデプロイ
```
そのためにはシステムを適切に切り離し、独立性を持たせる必要がある。  
  
切り離し方式には以下のレベルがある。  
```  
ソースレベル... パッケージ  
デプロイレベル... jar  
サービスレベル... サービス  
```  
  
### レイヤの切り離し  
UI、ユースケース、ビジネスロジック、インフラストラクチャは異なる頻度や理由で変更されるため  
これらをレイヤにより水平に切り離す。  
  
### ユースケースの切り離し  
ユースケースはシステムの水平レイヤを薄く垂直にスライスしたものである。  
別々のユースケース（注文追加・注文削除など）はUIを別々に分けたり、  
インフラストラクチャをユースケース毎にグループ化することで新しいユースケースを追加しても古いユースケースに影響を与えずに済む。  

# 境界線
ソフトウェアアーキテクチャとは、境界線を引く芸当である。これを「バウンダリー」と呼ぶ。  
システムに独立性を与えるためにはこれを実施する必要がある。  

### ソースレベルの切り離し
ソースレベルの切り離し方式では、境界をどのように引くべきか。  
方法としてはレイヤ化アーキテクチャやヘキサゴナルアーキテクチャを用いる。  
    
```  
ユーザーインターフェース層... ユーザーにアプリケーションの使い方を提供する  
アプリケーション層... ビジネスロジックの使い方を提供する  
ドメイン層... ビジネスロジックを提供する  
インフラストラクチャ層... 記録や通信の仕組み（マシンリソースの使い方）を提供する。  
ポート&アダプター層... アプリケーションの使い方を提供する  
```  
※ポート&アダプターパターン（ヘキサゴナルアーキテクチャ）  
アプリケーションを、ユーザー、プログラム、自動テストあるいはバッチスクリプトから、同じように駆動できるようにする設計。    

```  
最も上位レベル：ドメイン層  
次に上位レベル：アプリケーション層  
下位レベル：ユーザーインターフェース層、インフラストラクチャ層、ポート&アダプター層  

上位レベル... 方針を含んだモジュール（クラス・コンポーネント）  
下位レベル... 詳細を含んだモジュール（クラス・コンポーネント）  
```  

境界の越え方(依存の方向）が重要である。  
  
上位レベルのモジュールは下位モジュールに依存してはいけない。（方針が詳細に振り回されてはいけない。詳細はプラグインであるべき。DIP）  
アプリケーション層にとってユーザーにどのように利用されるかは詳細にすぎないし、  
ユーザーはアプリケーション層の方針に従って利用する。  

### デプロイレベルの切り離し
デプロイレベルとはjarのことを指す。（ライブラリとしてのjarであり実行可能jarやwarではない）  
全ての機能が同一プロセッサとアドレス空間に属するため、ソースレベルの切り離しと同じになる。  
  
### サービスレベルの切り離し
最も強い境界である。下位レベルのサービスは上位レベルのサービスに「プラグイン」されるべきである。  
上位レベルのサービスのソースコードには、下位レベルのサービスの物理的な情報（URIなど）を含めてはいけない。    

# 方針とレベル  
優れたアーキテクチャではどんな場合でも下位レベルのコンポーネントが上位レベルのコンポーネントに依存するように設計する。  
「レベル」の厳密な定義は「入力と出力からの距離」である。  
  
# 叫ぶアーキテクチャ  
アーキテクチャは、システムで使用しているフレームワークではなくドメインについての情報を伝える必要がある。  
例えばヘルスケアシステムを構築しているならば  
新しく参加したプログラマがリポジトリを見たときに、「ああ、これはヘルスケアシステムだ」と思えるようにしておくべきだ。  
  
# クリーンアーキテクチャ  
![クリーンアーキテクチャ](/picture/クリーンアーキテクチャ.jpeg "クリーンアーキテクチャ")  
![クリーンアーキテクチャ2](/picture/クリーンアーキテクチャ2.jpeg "クリーンアーキテクチャ2")  
![クリーンアーキテクチャ3](/picture/クリーンアーキテクチャ3.jpeg "クリーンアーキテクチャ3")  
  
  
DDDで用いるヘキサゴナルアーキテクチャは以下  
![ヘキサゴナルアーキテクチャ](/picture/ヘキサゴナルアーキテクチャ.png "ヘキサゴナルアーキテクチャ")  
  
  
# Humble Objectパターン  
Humble Objectパターンは、テストしにくい振る舞いを2つに分割することでテストをしやすくする考え方である。  
そのときどちらかをHumble（控えめ）にする。  
  
GUIの振る舞いの例では  
PresenterとViewの2つに分割し、ViewはHumbleオブジェクトとしてシンプルな振る舞いしか持たせない。  
参考：https://qiita.com/nrslib/items/a5f902c4defc83bd46b8  
  
データベースアクセスの例では  
データベースゲートウェイ（DDDにおけるリポジトリ）パターンがHumble Objectパターンの実装となる。  
リポジトリインターフェースの利用側と実装側の2つに分割し、実装する側をHumbleにする。  
  
サービスレベルでの分割もHumble Objectパターンで境界を作成することができる。  
  
アーキテクチャの境界の近くには、Humble Objectパターンが潜んでいる。  
境界を越える通信には、シンプルなデータ構造が含まれているように設計することで、  
境界がテストしにくい部分とテストしやすい部分に分割するようになる。  
そしてシステム全体のテスト容易性が大幅に向上する。  

# 部分的な境界  
本格的なアーキテクチャ境界はコストが高いため、部分的な境界を実装することも選択肢としてある。  
  
### 片方だけの境界（Strategy）  
Strategyパターンにより、下位レベルのクライアントから上位レベルのサービスへ境界を超える時にはサービス実装を気にしないが、  
サービス実装からのレスポンスは依存関係逆転なしで直接受け取る。  
上位レベルの変更の影響を下位レベルがもろに受ける。  
<img src="/picture/クリーンアーキテクチャ5.png" width="500px">
  
### シンプルな境界（Facade）  
片方だけの境界よりもシンプルな境界はFacadeパターンで実現する。  
下位レベルのクライアントは全てのサービス実装に推移的に依存している。  
サービス実装の変更はクライアントに影響を与える。  
<img src="/picture/クリーンアーキテクチャ4.png" width="500px">

# YAGNI  
YAGNI（You Aren't Going to Need It：あとで必要になることはない）の哲学では、抽象化が必要になることを予測してはいけないと提唱している。  
しかしアーキテクチャ境界が必要なところになかったとしたら、境界を追加するコストやリスクは非常に高いものとなる。  
ソフトウェアアーキテクトは未来に目を向けなければならない。  
頭を使って推測し、どこにアーキテクチャ境界があり、YAGNIとのバランスを取りながらどこまで実装するべきか判断しなければならない。  

# 事例  
システムの最初のアーキテクチャを決めるための第一歩は、アクターとユースケースを見つけることだ。  
<img src="/picture/クリーンアーキテクチャ6.png" width="500px">

アクターとユースケースがわかったので、とりあえずコンポーネントアーキテクチャを検討できるようになった。  
<img src="/picture/クリーンアーキテクチャ7.png" width="500px">
  
# 設計・コーディングのアプローチ  
悪魔は実装の詳細に宿る。気をつけておかないと最後の最後でつまずいてしまう。  
  
### レイヤーによるパッケージング  
Martin Fowlerや他の多くの人が最初はレイヤードアーキテクチャに従うのが得策だと述べている。シンプルだからだ。  
しかしソフトウェアが巨大になっていくと、コードを各レイヤのバケツに分けるだけでは手に負えなくなってしまう。  
また、レイヤードアーキテクチャはビジネスドメインについて何も叫ばない。全く異なるビジネスドメインのコードを並べてもそっくりになってしまう。  
<img src="/picture/クリーンアーキテクチャ8.png" width="200px">
  
### 機能によるパッケージング  
レイヤーは水平だが、こちらは垂直に分割しパッケージングする。  
関連する機能、ドメインの概念、集約のルート(DDD)に基づいて分割する。  
トップレベルのコードがビジネスドメインについて叫ぶようになり、また修正すべきユースケースが明確になる。  
<img src="/picture/クリーンアーキテクチャ9.png" width="200px">
水平レイヤーリング（レイヤーによるパッケージング）がうまくいかないチームが垂直レイヤーリング（機能によるパッケージング）に切り替える事例をよく見かける。  
もっと良いやり方がある。（ポート＆アダプター）  
  
### ポート＆アダプター  
ヘキサゴナルアーキテクチャのこと。  
<img src="/picture/クリーンアーキテクチャ10.png" width="200px">
<img src="/picture/クリーンアーキテクチャ11.png" width="200px">
  
### コンポーネントによるパッケージング  
「ビジネスロジック」と永続化コードを一つにまとめて「コンポーネント」にする。  
<img src="/picture/クリーンアーキテクチャ12.png" width="200px">

# メモ
```
・Humbleオブジェクトパターン再考
大前提：UI、ユースケース、ビジネスロジック、インフラストラクチャは異なる頻度や理由で変更されるためレイヤとして切り離されていなければならない。

各レイヤはレベルが異なる。「レベル」の定義は「入力と出力からの距離」である。レベルが違うと相手にするロジックの種別が異なる。
レベルが交わる場所には境界がある。
境界をまたがったクラスがある場合、異なる種別のロジックが交わっているためテストが難しい。
テスト観点が異なるし、テスト内容が境界をまたがっているため異なる頻度や理由で変更されるからだ。

ここでHumbleオブジェクトパターンの考えを用いる。目的は境界をまたがったクラスを2つに分離し、テストしやすくすることだ。
分離するということは、境界をまたぐメソッド呼び出しを最大限にシンプルにすることを指す。
方法としては境界の片方のロジックを経た結果をオブジェクトではなくデータ構造として、境界の向こうへメソッド呼び出しで渡す。
受け取った側では、境界の反対側で起きたことを一切認識することなく渡されたデータ構造を読み込みだけでシンプルに利用する。

こうすることで、データ構造を作るロジックのテストと、受け取ったデータ構造を利用するテストに分離される。
境界の向こうをモックにするなどしてテストの容易性を格段に向上させることができる。

メリットを具体的に言うと、それは受け取るデータ構造をモックにしてテストを実行できることだ。
もしデータ構造ではなくオブジェクトを受け取る構成だった場合、テストを楽にするにはオブジェクトをモックにしなければならない。
つまりそのオブジェクトのメソッドのロジックもモックで記述しなければならないので結局テストは複雑になるし、
オブジェクトのメソッドに修正があったときに、モックのメンテが漏れて古くなっていく（置いてけぼりになる）可能性も高い。
```
